#include "arena.h"
#include "arena_string.h" 

#pragma once
enum class ElementType 
{
    NONE,
    ROOT,
    TEXT,
    DIV,
    CUSTOM,
    GRID,
    IMG,
    VIDEO,
};

struct Selector
{
    int id;
    int style_count;
    
    char* name; // \0 terminated
    Style** styles; // All the styles selected by this selector
};

struct Style 
{
    int id;
    
    
};

enum class AttributeType
{
NONE,
CUSTOM, // For user defined args, name goes in value. Arg goes in Attribute binding
TEXT,
STYLE,
CLASS,
COLUMNS, // For grid element
ROWS, // For grid element
ROW, // For any element to specify which row/column of a parent grid it wants to be in
COLUMN,
SRC,
};

typedef void (*SubscribedFunction)(); // For user defined fn's, generated by #subto. also for markup bindings, generated by #if {expr}
typedef std::string (*SubscribedExpression)(); // For markup bindings, generated by {expr}

BoundExpression* register_new_func_expr(SubscribedFunction fn, int id);
BoundExpression* register_new_func_expr(SubscribedExpression fn, int id);
void subscribe_to(BoundExpression* expr, int target_bound_id);
void bound_var_changed(int bound_id);

struct BoundVariable
{
    int id;
    BoundExpression** subscribers;
    int subscriber_count;
};

struct BoundExpression 
{
    int id;
    union {
        SubscribedFunction eval_fn;
        SubscribedExpression eval_expr;
    };
    
    Element** subscribed_elements;
    int subscriber_count;
};

void NotifyVariableSubscirbers(BoundVariable*);
void NotifyExpressionSubscribers(BoundExpression*);

struct Attribute
{
    AttributeType type;
    char* static_value; // \0 terminated string with printf formatting to put the binding value in.
    int binding_id;
    
    // Cache //
    char* cached_value;
};

Element* CreateElement(DOM* dom, SavedTag* template);

// Note(Leo): Name should be NULL terminated
Selector* GetSelectorFromName(char* name);


struct Element 
{
    int id;
    int flags;
    ElementType type;
    
    Attribute* first_attribute;
    int num_attributes;
    
    Element* parent;
    Element* next_sibling;
    Element* first_child;
    
    // Cache related things //
    Style* cached_final_style;
    Style* cached_pre_attrib_style; // Style after compiling together all selected styles but before compiling Style="" 

    Style* cached_final_sizing;
};

DOM* InitializeDOM();

void CalculateStyles(DOM*);
void BuildRenderQue(DOM*);
void Draw(DOM*);

// Tells the program master to switch the page to the specified one
// Flags may tell the master wether to delete the curernt DOM or keep it and save the state
void SwitchPage(int id, int flags);

struct DOM
{
    Arena* static_strings;
    Arena* cached_values;
    Arena* dynamic_values;
    
    Arena* pointer_arrays;
    
    Arena* elements;
    Arena* attributes;
    Arena* bound_expressions;
    Arena* bound_vars;
    
    Arena* styles;
    Arena* selectors;
    
    Arena* changed_que;
    
    Arena* frame_arena; // Composted every frame
    
};