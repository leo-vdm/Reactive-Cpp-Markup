<code>
#include "platform.h"

struct InputBox : Component
{
    ArenaString* content;
    bool is_focused;
    uint32_t cursor_pos; // The index of the glyph that the cursor is on.
    uint32_t glyph_count; // The number of traversable glyphs
    DOM* dom;
    
    void* cursor;
    void* content_box;

    float cursor_width;
    float cursor_height;

    void CompMain(DOM* dom, CustomArgs* args)
    {
        this->dom = dom;
        content = CreateString(dom->strings);
        cursor_width = 5;
        cursor_height = 50;
    }
    
    void OnEvent(DOM* dom, Event* event)
    {
        switch(event->type)
        {
            // Note(Leo): We only get key events if we are focused
            case(EventType::KEY_DOWN):
            {
                user_input(event);
            
                break;
            }
            // Note(Leo): We only have 1 focusable element here so we dont bother checking an ID 
            case(EventType::FOCUSED):
            {
                #if PLATFORM_ANDROID
                    PlatformShowVirtualKeyboard(true);
                #endif
                            
                is_focused = true;
                break;
            }
            case(EventType::DE_FOCUSED):
            {
                #if PLATFORM_ANDROID
                    // Todo(Leo): Do we need to do this?
                    //PlatformShowVirtualKeyboard(false);
                #endif
                is_focused = false;
                break;
            }
            case(EventType::VIRTUAL_KEYBOARD):
            {
                #if PLATFORM_ANDROID
                if(!event->VirtualKeyboard.isShown)
                {
                    // Defocus our element when the keyboard is closed
                    FocusElement(dom, GetFocused(dom), NULL);
                }
                #endif
                
                break;
            }
            case(EventType::TICK):
            {
                update_cursor();
            
                break;
            }
            default:
            {
                break;
            }
        }
    }
    
    void update_cursor()
    {
        Element* content_el = (Element*)content_box;
        
        if(content_el && content_el->first_child)
        {
            Element* text_el = content_el->first_child;
            glyph_count = PlatformGetGlyphCount(text_el);
            
            FontPlatformShapedGlyph* cursor_glyph = NULL;
            
            // Handle the cursor wanting to be on the right side of the last glyph
            if(cursor_pos == glyph_count && glyph_count > 0)
            {
                cursor_glyph = PlatformGetGlyphAt(text_el, cursor_pos - 1);
                if(cursor_glyph)
                {
                    SetMarginL((Element*)cursor, { (cursor_glyph->placement_offsets.x + cursor_glyph->placement_size.x) - cursor_width, MeasurementType::PIXELS });
                    SetMarginT((Element*)cursor, { cursor_glyph->base_line - cursor_height, MeasurementType::PIXELS });
                }
            }
            else
            {
                cursor_glyph = PlatformGetGlyphAt(text_el, cursor_pos);
                if(cursor_glyph)
                {
                    SetMarginL((Element*)cursor, { cursor_glyph->placement_offsets.x, MeasurementType::PIXELS });
                    SetMarginT((Element*)cursor, { cursor_glyph->base_line - cursor_height, MeasurementType::PIXELS });
                }
            }
            
            PlatformUpdateStyle((Element*)cursor);
        }
        
    }
    
    void user_input(Event* in)
    {   
    
        switch(in->Key.code)
        {
            case(K_BACKSPACE):
            {
                remove_at_cursor(false);

                return;
            }
            case(K_DELETE):
            {
                remove_at_cursor(true);

                return;
            }
            case(K_SHIFT):
            case(K_SHIFT_R):
            case(K_SHIFT_L):
            case(K_WIN_L):
            case(K_WIN_R):
            case(K_ALT_L):
            case(K_ALT_R):
            case(K_ESCAPE):
            case(K_ENTER):
            case(K_CAPS):
            case(K_TAB):
            {
                return;
            }
            case(K_ARROW_L):
            {
                if(cursor_pos > 0)
                {
                    cursor_pos--;
                }
                
                break;
            }
            case(K_ARROW_R):
            {
                // Note(Leo): We allow moving past the last glyph so the cursor can be on its right side
                if(cursor_pos < glyph_count) //>
                {
                    cursor_pos++;
                }
                
                break;
            }
            default:
            {
                break;
            }
        }
        
        if(!in->Key.key_char)
        {
            return;
        }
        
        char added_chars[4];
        
        uint32_t len = PlatformUTF32ToUTF8(in->Key.key_char, (char*)&added_chars);
        
        Insert(content, (char*)&added_chars, static_cast<int>(len), cursor_pos);
        cursor_pos++;
    }
    
    // Remove the char at the cursor (forward) or behind the cursor (backward)
    void remove_at_cursor(bool remove_forward)
    {
        if(!content->length)
        {
            return;
        }
        
        // Cursor is at start so we cant remove anymore
        if(!cursor_pos && !remove_forward)
        {
            return;
        }
        else if(!remove_forward)
        {
            cursor_pos -= 1;
        }
        
        PlatformControlState* controls = PlatformGetControlState(dom);    
        
        Element* content_el = (Element*)content_box;
        
        if(content_el && content_el->first_child)
        {
            Element* text_el = content_el->first_child;
            FontPlatformShapedGlyph* removed = PlatformGetGlyphAt(text_el, cursor_pos);
            if(removed && (removed->buffer_index + removed->run_length) <= content->length)
            {
                Remove(content, removed->buffer_index, removed->run_length);
                SetMarginL((Element*)cursor, { removed->placement_offsets.x, MeasurementType::PIXELS });
                SetMarginT((Element*)cursor, { removed->base_line - cursor_height, MeasurementType::PIXELS });
                printf("Removing from %u to %u\n", removed->buffer_index, removed->run_length);
            }
        }
        
    }
    
    void clicked()
    {
        PlatformControlState* controls = PlatformGetControlState(dom);    
        
        Element* content_el = (Element*)content_box;
        
        if(content_el && content_el->first_child)
        {
            Element* text_el = content_el->first_child;
            FontPlatformShapedGlyph* clicked_glyph = PlatformGetGlyphAt(text_el, controls->cursor_pos);
            if(clicked_glyph)
            {
                
                //printf("Placing cursor at %f\n", clicked_glyph->base_line);
                //printf("Clicked glyph, index %u, length %u\n", clicked_glyph->buffer_index, clicked_glyph->run_length);
                SetMarginL((Element*)cursor, { clicked_glyph->placement_offsets.x, MeasurementType::PIXELS });
                SetMarginT((Element*)cursor, { clicked_glyph->base_line - cursor_height, MeasurementType::PIXELS });
                
                cursor_pos = PlatformGetGlyphIndex(text_el, clicked_glyph);
                printf("Glyph index %u\n", cursor_pos);
            }
        }
        
    }
};
</code>
<root>
<vdiv onclick="{e->clicked()}" focusable ticking>
	<hdiv this="{content_box}" condition="{return e->content->length > 0 && e->is_focused}">
		{content}
	</hdiv>
	<hdiv condition="{return e->content->length == 0 && e->is_focused}">
        Enter some text...
	</hdiv>
	<hdiv condition="{return !e->is_focused}">
        Click to focus!
	</hdiv>
	<hdiv class="cursor" this="{cursor}" condition="{return e->content->length > 0 && e->is_focused}"></hdiv>
</vdiv>

</root>

<style>
root, vdiv, hdiv {
	margin: grow, grow;
	width: fit;
	height: fit;
    font: "resources/fonts/NotoSans.ttf";
}

hdiv!hover {
	margin: grow, grow;
	color: 210, 210, 210;
	priority: 2;
    font: "resources/fonts/NotoSans.ttf";
}

cursor, cursor!hover {
    priority: 3;
    color: 12, 12, 12;
    width: 5px;
    height: 50px;
    display: relative;
}

</style>
